<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>小二郎的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="小二郎的博客">
<meta property="og:url" content="https://fish1010.github.io/index.html">
<meta property="og:site_name" content="小二郎的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yebo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="小二郎的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小二郎的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Fish1010.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-React学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/15/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-12-15T08:32:23.000Z" itemprop="datePublished">2020-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/15/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">React学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="React学习笔记"><a href="#React学习笔记" class="headerlink" title="React学习笔记"></a>React学习笔记</h3><h4 id="DOM相关概念"><a href="#DOM相关概念" class="headerlink" title="DOM相关概念"></a>DOM相关概念</h4><ul>
<li><p>DOM的本质:  浏览器中的概念,用js对象来表示页面上的元素,并且提供了操作DOM对象的API</p>
</li>
<li><p>什么是React中的虚拟DOM:  是框架中的概念,是程序员用js对象来模拟页面上的DOM元素和DOM嵌套关系</p>
</li>
<li><p>虚拟DOM的本质:  用js对象来模拟DOM元素和嵌套关系</p>
</li>
<li><p>虚拟DOM的目的:  就是为了实现页面元素的高效更新</p>
</li>
</ul>
<h4 id="打包发布运行"><a href="#打包发布运行" class="headerlink" title="打包发布运行"></a>打包发布运行</h4><ul>
<li><p>npm run build</p>
</li>
<li><p>npm install -g serve</p>
</li>
<li><p>serve build</p>
</li>
<li><p>访问<code>http://localhost:5000</code></p>
</li>
<li><p>元素渲染<code>ReactDOM.render(element, document.getElementById(&#39;root&#39;));</code></p>
</li>
</ul>
<h4 id="组件类别"><a href="#组件类别" class="headerlink" title="组件类别"></a>组件类别</h4><h5 id="无状态组件-function"><a href="#无状态组件-function" class="headerlink" title="无状态组件: function"></a>无状态组件: function</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有状态组件-class"><a href="#有状态组件-class" class="headerlink" title="有状态组件: class"></a>有状态组件: class</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>this.state: 改变组件的状态, 修改状态数据使用 this.setState()方法, setSetstate()方法的参数有两种,一种是对象( { xx: yy } ),一种是方法( ()=&gt;{ return } ),方法里面可以写参数,有两个参数,一个prevState是上一个状态的结果,还有一个是props对象</p>
</li>
<li><p>this.setState一般延迟执行,状态更新属于异步,如果想要将上一个状态作为下一个状态的参数传入,就可以使用prevState参数,或者</p>
</li>
<li><p>由于setState是异步的,如果需要用setState获取最新的状态就需要在回调函数里获取</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState( ()=&#123; <span class="built_in">return</span> &#125;, ()=&gt;&#123;this.state.xx&#125; )</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过setState添加state中数组属性的值,不能直接用push, push只是返回数组长度,有三种方法</p>
<ul>
<li><ol>
<li>可以将state中数组属性先备份,<code>let newArrs = this.state.arrs.slice()  newArrs.push(&#123;  id:1, title: &quot;xx&quot; &#125;), this.setState(&#123; arrs: newArrs &#125;)</code></li>
</ol>
</li>
<li><ol start="2">
<li>使用concat <code>&#123;arrs: this.state.arrs.concat&#123;id:1, title: &quot;xxx&quot;&#125; &#125;</code></li>
</ol>
</li>
<li><ol start="3">
<li>数组备份的第二种方法, let newArrs = [ …this.state.arrs ]</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul>
<li><p><code>componentDidMount()</code>方法在组件输出呈现到DOM之后自动运行</p>
</li>
<li><p><code>componentWillUnmount()</code>在组件消失不在呈现时执行</p>
</li>
</ul>
<h4 id="遍历列表数组"><a href="#遍历列表数组" class="headerlink" title="遍历列表数组"></a>遍历列表数组</h4><ul>
<li><p>需要用到map函数, map函数需要加上唯一索引key={}, Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。没有唯一值的时候可以使用index，但是官方不建议，会导致渲染变慢。</p>
</li>
<li><p>React列表渲染为什么尽量不要把索引设置为key值</p>
<ul>
<li>因为react原理是先生成虚拟DOM，然后生成真实DOM，通过同层对比比较新旧DOM，直接操作DOM，改变有区别的内容，所以极大地提高了性能，如果不用索引为key时，程序能够快速的找到差异，虽然index作为key也能找到差异，但是必须对比整个虚拟DOM，大大的消耗了新旧DOM的对比性能，还有可能导致组件状态问题。</li>
</ul>
</li>
</ul>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul>
<li><p>阻止事件默认提交行为: e.preventDefault();</p>
</li>
<li><p>在事件需要提交参数时或者防止this指代问题</p>
<ul>
<li><p>外部的handleClick使用箭头函数 let handleClick= ()=&gt;{}</p>
</li>
<li><p>在单击事件函数中引用外部函数 onClick={ handleClick }</p>
</li>
<li><p>在单击事件函数中使用箭头函数传参 onClick={ ()=&gt;{ handleClick(element) } }</p>
</li>
<li><p>或者使用 onClick={ this.handleClick.bind(this, id) }</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优化: 为了使this指代不会出错并且只需要执行一次,就可以在组件调用只执行一次中写this.handleClickcopy = this.handleClick.bind(this, ele), 接着在单击事件函数中调用this.handleClickcopy函数就行,ele参数为默认值,可有可无</span><br></pre></td></tr></table></figure>

<h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><ul>
<li>需要改变提交表单的value值,需要用到 this.state={}   this.setState()   onChange={}  通过外部函数的event事件改变state的value值, 获取表单最新的value值  需要用到 value : e.target.value</li>
</ul>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul>
<li>路由会使用到三个组件;  需要下载  npm install react-router-dom –save  在引入三个组件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;HashRouter&gt;</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/article&quot;</span> component=&#123;article&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/article/:id&quot;</span> component=&#123;article&#125;&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;/Switch&gt;</span><br><span class="line">&lt;/HashRouter&gt;</span><br><span class="line"></span><br><span class="line">&lt;Link to=<span class="string">&quot;/article&quot;</span>&gt;文章管理&lt;/Link&gt;  代替a标签进行跳转</span><br></pre></td></tr></table></figure>

<ul>
<li><p>path路由的路径,  exact路径的精准匹配,  component展现的组件内容, :id 特殊的占位符</p>
</li>
<li><p>点击提交进行跳转,在箭头函数里面写  this.props.history.push(“/article”)  固定写法</p>
</li>
<li><p>获取id  在挂起的生命周期函数中写   let id = this.props.match.params.id  路由提供的固定写法</p>
</li>
<li><p>子组件的数据依赖于父组件，就会执行componentWillReceiveProps</p>
</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li><p>shouldComponentUpdate 是做什么的</p>
<ul>
<li>这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</li>
</ul>
</li>
<li><p>react组件什么时候会重渲染？</p>
<ul>
<li>只有在组件的<code>state</code>变化时才会出发组件的重新渲染。状态的改变可以因为<code>props</code>的改变，或者直接通过<code>setState</code>方法改变。</li>
</ul>
</li>
<li><p><strong>State hook</strong>的主要作用就是获取需要的 state 和 更新state的方法</p>
</li>
<li><p>props和state相同点和不同点</p>
<ul>
<li><p>相同点：不管是props还是state的改变，都会引发render的重新渲染。都能由自身组件的相应初始化函数设定初始值。</p>
</li>
<li><p>不同点：</p>
<ul>
<li><p>1.初始值来源：<br>state的初始值来自于自身的getInitalState（constructor）函数；<br>props来自于父组件或者自身getDefaultProps（若key相同前者可覆盖后者）。</p>
</li>
<li><p>2.修改方式：<br>state只能在自身组件中setState，不能由父组件修改；<br>props只能由父组件修改，不能在自身组件修改。</p>
</li>
<li><p>3.对子组件：<br>props是一个父组件传递给子组件的数据流，这个数据流可以一直传递到子孙组件；<br>state代表的是一个组件内部自身的状态，只能在自身组件中存在。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Redux状态管理的流程"><a href="#Redux状态管理的流程" class="headerlink" title="Redux状态管理的流程"></a>Redux状态管理的流程</h4><ul>
<li><p>action是用户触发或程序触发的一个普通对象。 reducer是根据action操作来做出不同的数据响应，返回一个新的state。 store的最终值就是由reducer的值来确定的。（一个store是一个对象, reducer会改变store中的某些值） action -&gt; reducer -&gt; 新store -&gt; 反馈到UI上有所改变。</p>
</li>
<li><p>Redux中同步 action 与异步 action 最大的区别是什么</p>
<ul>
<li>同步只返回一个普通 action 对象。而异步操作中途会返回一个 promise 函数。当然在 promise 函数处理完毕后也会返回一个普通 action 对象。thunk 中间件就是判断如果返回的是函数，则不传导给 reducer，直到检测到是普通 action 对象，才交由 reducer 处理。</li>
</ul>
</li>
<li><p>Redux中的reducer只接受state，不能改变state，他只是用新数组进行深拷贝，返回一个新的store</p>
</li>
<li><p>reducer必须是一个纯函数（如果函数的调用参数相同，则永远返回想同的结果，它不依赖于程序执行期间函数外部任何状态，或者数据的变化，必须依赖于其传入参数）</p>
</li>
<li><p>store必须唯一的，不能申明多个</p>
</li>
</ul>
<h4 id="什么是JSX"><a href="#什么是JSX" class="headerlink" title="什么是JSX"></a>什么是JSX</h4><ul>
<li>JSX是ECMAScript一个类似XML的语法扩展。基本上，它只是为React.createElement()函数提供语法糖，从而<strong>让我们在JavaScript中，使用类似HTML模板的语法，进行页面描述</strong>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fish1010.github.io/2020/12/15/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckipqd1760000d0tr4jufbfov" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/15/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-12-15T03:48:33.000Z" itemprop="datePublished">2020-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/15/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Vue学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="VUE学习笔记"><a href="#VUE学习笔记" class="headerlink" title="VUE学习笔记"></a>VUE学习笔记</h3><h4 id="直接通过cdn引入"><a href="#直接通过cdn引入" class="headerlink" title="直接通过cdn引入"></a>直接通过cdn引入</h4><ul>
<li><p><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p>第二部实例化vue对象</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Vue (&#123;</span><br><span class="line">  el: <span class="string">&quot;#box&quot;</span>, //element需要获取的元素,一定是html中的根容器box内元素</span><br><span class="line">  data:&#123; //用于数据的存储  //调用 &#123;&#123; name &#125;&#125;</span><br><span class="line">      name: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">      job: <span class="string">&quot;程序员&quot;</span>,</span><br><span class="line">      baidu: <span class="string">&quot;www.baidu.com&quot;</span>,</span><br><span class="line">      web: <span class="string">&quot;&lt;a href=&quot;</span>www.baidu.com<span class="string">&quot;&gt;百度&lt;/a&gt;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123; //用于方法的存储 //调用 &#123;&#123; hello(<span class="string">&quot;Morning&quot;</span>) &#125;&#125;</span><br><span class="line">      hello: <span class="keyword">function</span>( time )&#123;</span><br><span class="line">          <span class="built_in">return</span> <span class="string">&quot;Good &quot;</span> + time + <span class="string">&quot; &quot;</span> + this.name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Vue-CLI脚手架搭建"><a href="#Vue-CLI脚手架搭建" class="headerlink" title="Vue CLI脚手架搭建"></a>Vue CLI脚手架搭建</h4><ul>
<li><p>优势:</p>
<ul>
<li><p>是通过webpack搭建的开发环境</p>
</li>
<li><p>使用ES6语法</p>
</li>
<li><p>打包和压缩JS为一个文件</p>
</li>
<li><p>项目文件在环境中编译而不是浏览器</p>
</li>
<li><p>实现页面自动刷新</p>
</li>
</ul>
</li>
<li><p>步骤:</p>
<ul>
<li><p>检查安装node.js ( node -v )</p>
</li>
<li><p>检查安装npm ( npm -v )</p>
</li>
<li><p>npm install –global vue-cli</p>
</li>
<li><p>检查vue ( vue –version )</p>
</li>
<li><p>进入指定文件下创建项目 ( vue init webpack my-project )</p>
</li>
<li><p>进入项目内部 ( cd my-project )</p>
</li>
<li><p>下载相关依赖 ( npm install )</p>
</li>
<li><p>启动项目 ( npm run dev )</p>
</li>
<li><p>访问<code>http://localhost:8080</code>查看结果</p>
</li>
</ul>
</li>
</ul>
<h4 id="项目目录详解"><a href="#项目目录详解" class="headerlink" title="项目目录详解"></a>项目目录详解</h4><ul>
<li><p><code>build</code>:  基于webpack的配置信息</p>
</li>
<li><p><code>config</code>:  项目核心配置</p>
<ul>
<li><p>修改端口号</p>
</li>
<li><p>自动打开网址</p>
</li>
</ul>
</li>
<li><p><code>node_module</code>:  安装依赖模块</p>
</li>
<li><p><code>src/main.js</code>:  程序入口文件</p>
</li>
<li><p><code>src/app.vue</code>:  程序入口vue组件</p>
</li>
<li><p><code>src/assets</code>:  资源文件夹(一般是静态资源)</p>
</li>
<li><p><code>static</code>:  纯静态资源(直接拷贝到里面)</p>
</li>
<li><p><code>.babelrc</code>:  ES6转码器, 转换成浏览器识别的ES5</p>
</li>
<li><p><code>.editorconfig</code>:  编辑配置文件</p>
</li>
<li><p><code>.gitignore</code>:  过滤一些版本控制的文件</p>
</li>
<li><p><code>index.html</code>:  整个项目加载的文件</p>
</li>
<li><p><code>package.json</code>:  非常完整的项目版本组件等基本信息介绍</p>
</li>
</ul>
<h4 id="事件指令"><a href="#事件指令" class="headerlink" title="事件指令"></a>事件指令</h4><ul>
<li><p>通过<code>v-bind</code>: 绑定样式, 可以拿到baidu的值, 给a标签的href属性赋值, 写法是<code>v-bind:href=&quot;baidu&quot;</code>, 还可以绑定type,value等</p>
</li>
<li><p>通过<code>v-html</code>: 绑定,可以拿到web的值, 获取到完整的a标签, 显示可跳转的百度</p>
</li>
<li><p>通过<code>v-on</code>: 或者@将事件绑定到标签上</p>
</li>
<li><p><code>v-model</code> = “”  <strong>双向数据绑定</strong></p>
</li>
</ul>
<h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><ul>
<li><p>在标签中自定义<code>v-name</code> ( 不给定值得情况 ) ( 给定值情况 ) ( 给定参数情况 )</p>
</li>
<li><p>在main.js中使用( 全局使用 )</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive( <span class="string">&#x27;name&#x27;</span>, &#123; </span><br><span class="line">  <span class="built_in">bind</span>(el, binding, vnode)&#123; </span><br><span class="line">    el.style.color =  <span class="string">&quot;#&quot;</span> + Math.random().toString(16).slice(2, 8);</span><br><span class="line">    <span class="keyword">if</span>(binding.value == <span class="string">&quot;value&quot;</span>)&#123;  // v-name = <span class="string">&quot;&#x27;value&#x27;&quot;</span>(给定值的情况)</span><br><span class="line">              el.style.maxWidth = <span class="string">&quot;1200px&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(binding.arg == <span class="string">&quot;props&quot;</span>)&#123; //v-name:props= <span class="string">&quot;&#x27;value&#x27;&quot;</span>(给定参数的情况)</span><br><span class="line">              el.style.backgroundColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在子组件内部实现</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">directives:&#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: &#123;</span><br><span class="line">    <span class="built_in">bind</span>(el, binding, vnode)&#123; // <span class="built_in">bind</span>为钩子函数</span><br><span class="line">      el.style.color = red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><ul>
<li><p>修饰符可以串联,使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。</p>
</li>
<li><p><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</p>
</li>
<li><p><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。执行完刷新页面</p>
</li>
<li><p><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</p>
</li>
<li><p><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</p>
</li>
<li><p><code>.&#123;keyCode | keyAlias&#125;</code> - 只当事件是从特定键触发时才触发回调。</p>
</li>
<li><p><code>.native</code> - 监听组件根元素的原生事件。</p>
</li>
<li><p><code>.once</code> - 只触发一次回调。</p>
</li>
<li><p><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</p>
</li>
<li><p><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</p>
</li>
<li><p><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</p>
</li>
<li><p><code>.passive</code> - (2.3.0) 以 <code>&#123; passive: true &#125;</code> 模式添加侦听器</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要把 `.passive` 和 `.prevent` 一起使用，因为 `.prevent` 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，`.passive` 会告诉浏览器你不想阻止事件的默认行为。</span><br></pre></td></tr></table></figure>

<h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter=<span class="string">&quot;submit&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>.enter</code></p>
</li>
<li><p><code>.tab</code></p>
</li>
<li><p><code>.delete</code> (捕获“删除”和“退格”键)</p>
</li>
<li><p><code>.esc</code></p>
</li>
<li><p><code>.space</code></p>
</li>
<li><p><code>.up</code></p>
</li>
<li><p><code>.down</code></p>
</li>
<li><p><code>.left</code></p>
</li>
<li><p><code>.right</code></p>
</li>
<li><p>你还可以通过全局 <code>config.keyCodes</code> 对象<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#keyCodes">自定义按键修饰符别名</a>：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 可以使用 `v-on:keyup.f1`</span><br><span class="line">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>

<h4 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h4><ul>
<li><p><code>.ctrl</code></p>
</li>
<li><p><code>.alt</code></p>
</li>
<li><p><code>.shift</code></p>
</li>
<li><p><code>.meta</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 Mac 系统键盘上，meta 对应 <span class="built_in">command</span> 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.exact</code>修饰符允许你控制由精确的系统修饰符组合触发的事件。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl.exact=<span class="string">&quot;onCtrlClick&quot;</span>&gt;A&lt;/button&gt;</span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.exact=<span class="string">&quot;onClick&quot;</span>&gt;A&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>鼠标按键修饰符</p>
<ul>
<li><p><code>.left</code></p>
</li>
<li><p><code>.right</code></p>
</li>
<li><p><code>.middle</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="双向数据绑定-input-textarea-select"><a href="#双向数据绑定-input-textarea-select" class="headerlink" title="双向数据绑定  input / textarea / select"></a>双向数据绑定  input / textarea / select</h4><ul>
<li><p>通过给标签添加 ref=” name1 “ , 用<code>v-on</code>: 绑定事件调用方法, 在方法中用this.name = this.$refs.name1.value 进行赋值</p>
</li>
<li><p>还可以用<code>v-model=&quot; &quot;</code>代替方法调用, 实现双向数据绑定</p>
</li>
</ul>
<h4 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h4><ul>
<li><p>computed和methods实现的效果完全一样,但是, 当我们重新渲染模板的时候,计算属性会立刻返回之前的值，而不用去执行函数，这样就提高了我们的渲染的效率.</p>
</li>
<li><p>在computed属性对象中定义计算属性的方法，在页面中使用<code>&#123;&#123;方法名&#125;&#125;</code>来显示计算的结果。</p>
</li>
<li><p>通过getter\setter实现对属性数据的显示和监视，计算属性是基于它们的<strong>响应式依赖</strong>进行缓存的，多次读取只执行一次getter计算。</p>
</li>
<li><p>(如果使用methods方法, 调用里面的某个方法,会将methods的所有方法全部调用,性能及其不好,而computed只会渲染所需要的方法,会提高性能,渲染效率高)</p>
</li>
</ul>
<h4 id="动态绑定css样式"><a href="#动态绑定css样式" class="headerlink" title="动态绑定css样式"></a>动态绑定css样式</h4><ul>
<li><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</p>
<ul>
<li><code>&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</code></li>
</ul>
</li>
<li><p>我们也可以在这里绑定一个返回对象的<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/computed.html">计算属性</a>。这是一个常用且强大的模式：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: this.error &amp;&amp; this.error.type === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表：</p>
<ul>
<li><code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><ul>
<li><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染, 否则就不存在DOM结构里面,(与v-show有区别) 也可以用 <code>v-else</code> 添加一个“else 块”：</p>
<ul>
<li>在<code>&lt;template&gt;</code>元素上使用<code>v-if</code>指令条件渲染分组</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=<span class="string">&quot;ok&quot;</span>&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>v-else</code> 指令来表示 <code>v-if</code> 的“else 块”：</p>
<ul>
<li><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别。</li>
</ul>
</li>
<li><p><code>v-else-if</code>(新增)，顾名思义，充当 <code>v-if</code> 的<code>else-if</code>块，可以连续使用：</p>
</li>
<li><p><code>key</code>管理可复用的元素</p>
<ul>
<li>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</li>
</ul>
</li>
<li><p><code>v-show</code> 指令根据条件展示元素。用法大致一样：</p>
<ul>
<li>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS property <code>display</code>, 不展示就使display为none,站位隐藏, <code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</li>
</ul>
</li>
</ul>
<h4 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`v-if`是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</span><br><span class="line"></span><br><span class="line">`v-if` 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</span><br><span class="line"></span><br><span class="line">相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</span><br><span class="line"></span><br><span class="line">一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。</span><br></pre></td></tr></table></figure>

<ul>
<li>不推荐 <code>v-if</code> 与 <code>v-for</code> 一起使用, 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级</li>
</ul>
<h4 id="v-for循环"><a href="#v-for循环" class="headerlink" title="v-for循环"></a>v-for循环</h4><ul>
<li><p>预期: <code>Array | Object | number | string | Iterable (2.6 新增)</code></p>
</li>
<li><p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias(别名) in expression</code>，为当前遍历的元素提供别名：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=<span class="string">&quot;item in items&quot;</span>&gt;</span><br><span class="line">  &#123;&#123; item &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>同样可以使用<code>&lt;template&gt;</code>渲染多个标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给v-for添加一个index,在绑定一个key值,表示唯一性,增加代码运行速率,</span><br><span class="line">&lt;template v-for=<span class="string">&quot;(item, index) in items&quot;</span> :key=<span class="string">&quot;item.name&quot;</span> &gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="组件的应用"><a href="#组件的应用" class="headerlink" title="组件的应用"></a>组件的应用</h4><ul>
<li>Vue 注册全局组件的示例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个名为 button-counter 的新组件</span><br><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&gt; 因为组件是可复用的 Vue 实例，所以它们与 `new Vue` 接收相同的选项，例如 `data`、`computed`、`watch`、`methods` 以及生命周期钩子等。仅有的例外是像 `el` 这样根实例特有的选项。</span><br><span class="line">&gt; 一个组件的data选项必须是一个函数</span><br></pre></td></tr></table></figure>

<ul>
<li><p>组件的组织</p>
<ul>
<li><p>通常一个应用会以一棵嵌套的组件树的形式来组织</p>
</li>
<li><p>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。至此，我们的组件都只是通过 <code>Vue.component</code> 全局注册的：</p>
<ul>
<li>全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</li>
</ul>
</li>
<li><p>注意局部注册的组件在其子组件中不可用</p>
</li>
</ul>
</li>
<li><p>通过propos向子组件传递数据</p>
<ul>
<li>Prop 是你可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>每个组件必须只有一个根元素</strong></p>
</li>
<li><p>监听子组件事件</p>
<ul>
<li>在其父组件中，我们可以通过添加一个 <code>postFontSize</code>:1  数据 property 来支持这个功能：</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style=<span class="string">&quot;&#123; fontSize: postFontSize + &#x27;em&#x27; &#125;&quot;</span>&gt;   &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h4><ul>
<li><p>组件一般包含三个部分</p>
<ul>
<li><strong>模板:html结构 / 行为: 处理逻辑 / 样式:解决样式</strong></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import ComponentA from <span class="string">&#x27;./ComponentA.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">    等同于 ComponentA: ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个属于局部注册, 需要注册components 组件</span><br><span class="line">全局注册,需要在main.js中 使用Vue.component()</span><br></pre></td></tr></table></figure>

<h4 id="组件的css作用域"><a href="#组件的css作用域" class="headerlink" title="组件的css作用域"></a>组件的css作用域</h4><ul>
<li><code>&lt;style scoped&gt;  &lt;/style&gt;</code> 样式添加scoped就只会在当前作用域起作用,  不然就会全局起作用</li>
</ul>
<h4 id="组件的传值"><a href="#组件的传值" class="headerlink" title="组件的传值"></a>组件的传值</h4><ul>
<li><p>HTML 中的 attribute 名是大小写不敏感的,prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名</p>
</li>
<li><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：</p>
</li>
<li><p>传值: number String Boolean  <strong>改变一个地方得值, 其他引用的地方不会改变</strong></p>
</li>
<li><p>父组件向子组件传值:</p>
<ul>
<li><p>在父组件的data设置usersArray数组值, 在父组件内引用子组件并通过<code>v-bind:users=&quot;usersArray&quot;</code>绑定</p>
</li>
<li><p>在子组件的export default 中,用props接收</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default&#123;</span><br><span class="line">    name: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    //props:[<span class="string">&quot;users&quot;</span>]</span><br><span class="line">    props: &#123;</span><br><span class="line">        users:&#123;</span><br><span class="line">            <span class="built_in">type</span>: Array,</span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>传引用: array object  <strong>传引用改变一个地方的值,所有被引用过的地方得值都会改变</strong></p>
</li>
<li><p>子组件向父组件传值:</p>
<ul>
<li><p>子组件写一个方法, 方法的值为 <code>this.$emit( &quot;changeTitle(父组件引用的方法名)&quot;, 子组件传的值 )</code></p>
</li>
<li><p>在父组件用v-on:changeTitle=”updataTitle( $event(接收子组件传的值) )”</p>
</li>
<li><p>在父组件写个updataTitle( title )方法</p>
</li>
</ul>
</li>
</ul>
<h4 id="生命周期函数钩子"><a href="#生命周期函数钩子" class="headerlink" title="生命周期函数钩子"></a>生命周期函数钩子</h4><ul>
<li><p>beforeCreate ( 组件实例化之前执行的函数)</p>
</li>
<li><p>created ( 组件实例化完毕,但是页面还没显示)</p>
</li>
<li><p>beforeMount ( 组件挂载前,页面仍未显示,但是虚拟Dom已经配置)</p>
</li>
<li><p>mounted ( 组件挂载后,此方法执行后,页面显示)</p>
</li>
<li><p>beforeUpdate (组件更新前,页面仍未更新,但是虚拟Dom已经配置)</p>
</li>
<li><p>updated ( 组件更新,此方法执行后,页面显示更新)</p>
</li>
<li><p>beforeDestory (组件销毁前)</p>
</li>
<li><p>destoryed (组件销毁)</p>
</li>
</ul>
<h4 id="路由请求"><a href="#路由请求" class="headerlink" title="路由请求"></a>路由请求</h4><ul>
<li><p>首先需要在终端, 下载路由 <code>npm install vue-router --save-dev</code></p>
</li>
<li><p>在main.js中引进<code>import VueRouter from &#39;vue-router&#39;</code></p>
</li>
<li><p>在main.js中使用 <code>Vue.use(VueRouter)</code></p>
</li>
<li><p>在main.js中配置路由</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;path: <span class="string">&quot;路由的路径&quot;</span>, component: 展示的组件&#125;</span><br><span class="line">    ],</span><br><span class="line">    mode: <span class="string">&quot;history&quot;</span>  //取消网址中的/<span class="comment">#/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在main.js中的实例化中使用router <code>router: router</code></p>
</li>
<li><p>在app容器中放置需要展示的页面组件</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;</span><br><span class="line">  &lt;component&gt;&lt;/component</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用路由跳转 <code>&lt;router-link to=&quot;/helloworld&quot;&gt; helloworld &lt;/router-link&gt;</code> 不使用a标签</li>
</ul>
<blockquote>
<p>a标签也可以实现跳转,但是a标签每次点击跳转页面会重新全部加载,性能不好</p>
</blockquote>
<h4 id="vue-resourse-和路由功能相似"><a href="#vue-resourse-和路由功能相似" class="headerlink" title="vue-resourse (和路由功能相似)"></a>vue-resourse (和路由功能相似)</h4><ul>
<li><p>安装 <code>npm install vue-resource --save-dev</code></p>
</li>
<li><p>在main.js中引进<code>import VueResource from &#39;vue-resource&#39;</code></p>
</li>
<li><p>在main.js中使用 <code>Vue.use(VueResource)</code></p>
</li>
<li><p>在全局范围都可以使用数据请求</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span></span> () &#123;</span><br><span class="line">        this.<span class="variable">$http</span>.get(<span class="string">&quot;http://jsonplaceholder.typicode.com/users&quot;</span>)</span><br><span class="line">            .<span class="keyword">then</span>((data)=&gt;&#123;</span><br><span class="line">                this.users = data.body</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h4><ul>
<li><p>在标签内部使用 <code>&#123;&#123; blog.title | to-uppercase &#125;&#125;, &#123;&#123; blog.body | limit &#125;&#125;</code></p>
</li>
<li><p>在main.js中使用( 可以全局使用 )</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter( <span class="string">&quot;to-uppercase&quot;</span>, <span class="keyword">function</span>(value)&#123;</span><br><span class="line">    <span class="built_in">return</span> value.toUpperCase();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.filter( <span class="string">&quot;limit&quot;</span>, <span class="keyword">function</span>(value)&#123;</span><br><span class="line">    <span class="built_in">return</span> value.slice(0, 100) + <span class="string">&quot; ...&quot;</span>;</span><br><span class="line">&#125; ) </span><br></pre></td></tr></table></figure>

<ul>
<li>在子组件内部实现</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default&#123;</span><br><span class="line">    filters:&#123;</span><br><span class="line">        // <span class="string">&quot;to-uppercase&quot;</span>: <span class="keyword">function</span> (value)&#123;</span><br><span class="line">        // <span class="built_in">return</span> value.toUpperCase();    </span><br><span class="line">        // &#125;</span><br><span class="line">        toUppercase(value)&#123;</span><br><span class="line">            <span class="built_in">return</span> value.toUpperCase();</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">limit</span>(value)&#123;</span><br><span class="line">            <span class="built_in">return</span> value.slice(0, 100) + <span class="string">&quot; ...&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件之间的交互"><a href="#组件之间的交互" class="headerlink" title="组件之间的交互"></a>组件之间的交互</h4><ul>
<li><p>$http   (用于get/post获取数据)</p>
</li>
<li><p>$props   (单向数据绑定，只能由父组件传向子组件)，传递方式有静态值和动态值（动态需要用v-bind绑定）</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;我是父组件！&lt;/h1&gt;</span><br><span class="line">    //通过自定义属性传递数据</span><br><span class="line">    &lt;child message=<span class="string">&quot;我是子组件一！&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line">    &lt;child v-bind:message=<span class="string">&quot;msg&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from <span class="string">&#x27;../components/child.vue&#x27;</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components: &#123;Child&#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span>&#123;</span><br><span class="line">            msg: <span class="string">&#x27;我是子组件三！&#x27;</span>+ Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="built_in">export</span> default &#123;</span><br><span class="line">  props: [<span class="string">&#x27;message&#x27;</span>] //声明一个自定义的属性</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>this.$refs.Tips.changeFlag();  (用于父组件调用子组件中的事件方法)</p>
<ul>
<li><p>如果ref用在子组件上，指向的是组件实例，可以理解为对子组件的索引，通过$ref可能获取到在子组件里定义的属性和方法。</p>
</li>
<li><p>如果ref在普通的 DOM 元素上使用，引用指向的就是 DOM 元素，通过$ref可能获取到该DOM 的属性集合，轻松访问到DOM元素，作用与JQ选择器类似。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">         &lt;h1&gt;我是父组件！&lt;/h1&gt;</span><br><span class="line">         &lt;child ref=<span class="string">&quot;msg&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import Child from <span class="string">&#x27;../components/child.vue&#x27;</span></span><br><span class="line"> <span class="built_in">export</span> default &#123;</span><br><span class="line"> mounted: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log( this.<span class="variable">$refs</span>.msg);</span><br><span class="line">  this.<span class="variable">$refs</span>.msg.getMessage(<span class="string">&#x27;我是子组件一！&#x27;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">      <span class="built_in">return</span>&#123;</span><br><span class="line">        message:<span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      getMessage(m)&#123;</span><br><span class="line">        this.message=m;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>prop和$ref之间的区别</p>
<ul>
<li><p>prop 着重于数据的传递，它并不能调用子组件里的属性和方法。像创建文章组件时，自定义标题和内容这样的使用场景，最适合使用prop。</p>
</li>
<li><p>$ref 着重于索引，主要用来调用子组件里的属性和方法，其实并不擅长数据传递。而且ref用在dom元素的时候，能使到选择器的作用，这个功能比作为索引更常有用到。</p>
</li>
</ul>
</li>
<li><p>通过$emit 实现通信</p>
<ul>
<li>$emit 实现子组件向父组件通信</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;child @getMessage=<span class="string">&quot;showMsg&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child from <span class="string">&#x27;../components/child.vue&#x27;</span></span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    components: &#123;Child&#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">      <span class="built_in">return</span>&#123;</span><br><span class="line">        title:<span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      showMsg(title)&#123;</span><br><span class="line">        this.title=title;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;h3&gt;我是子组件！&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">export</span> default &#123;</span><br><span class="line">    mounted: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">&#x27;getMessage&#x27;</span>, <span class="string">&#x27;我是父组件！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>this.$route.params.id  ( 接收父组件点击传的id )</p>
</li>
<li><p>this.$router.push({ path:”/“ })  跳转页面</p>
</li>
</ul>
<h4 id="Vue和React的区别与联系"><a href="#Vue和React的区别与联系" class="headerlink" title="Vue和React的区别与联系"></a>Vue和React的区别与联系</h4><ul>
<li><p>相同点:</p>
<ul>
<li><p>他们都是JavaScript的UI框架，Reat与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。</p>
</li>
<li><p>最大一个相似之处，就是他们都使用了一种叫’Virtual DOM’(虚拟DOM)的东西。</p>
</li>
</ul>
</li>
<li><p>不同点:</p>
<ul>
<li><p>最大的不同就是React推广了Virtual DOM（虚拟DOM）并创造了新的语法——JSX，JSX允许开发者在JavaScript中书写HTML</p>
</li>
<li><p>Vue使用模板系统, 模板用的就是普通的HTML，通过Vue来整合现有的系统是比较容易的，不需要整体重构。同时Vue更容易学习.</p>
</li>
<li><p>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</p>
</li>
<li><p>而对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过<code>shouldComponentUpdate</code>这个生命周期方法来进行控制。但Vue将此视为默认的优化。</p>
</li>
</ul>
</li>
</ul>
<h4 id="配置Json-server"><a href="#配置Json-server" class="headerlink" title="配置Json-server"></a>配置Json-server</h4><ul>
<li><p>全局安装 <code>npm install -g json-server</code></p>
</li>
<li><p>新建一个JsonServer文件,并且进入JsonServer文件</p>
</li>
<li><p>进行初始化 <code>npm init</code></p>
</li>
<li><p>在JsonServer这个文件安装服务模块 <code>npm install json-server --save</code></p>
</li>
<li><p>配置启动命令: 在JsonServer文件下的.json文件的值为scripts ( 可以不修改 )</p>
<ul>
<li>“test”:”…”  改为  “json:server”:”json-server –watch db.json”</li>
</ul>
</li>
<li><p>在JsonServer文件下面新建db.json, 添加数据</p>
</li>
<li><p>启动  npm run json:server</p>
</li>
</ul>
<h4 id="使用json-server"><a href="#使用json-server" class="headerlink" title="使用json-server"></a>使用json-server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有用户信息</span><br><span class="line">http://localhost:3000/users</span><br><span class="line"></span><br><span class="line">// 获取id为1用户信息</span><br><span class="line">http://localhost:3000/users/1</span><br><span class="line"></span><br><span class="line">// 获取所有公司信息</span><br><span class="line">http://localhost:3000/companies</span><br><span class="line"></span><br><span class="line">// 获取id为1公司信息</span><br><span class="line">http://localhost:3000/companies/1</span><br><span class="line"></span><br><span class="line">// 获取隶属某个公司的用户</span><br><span class="line">http://localhost:3000/companies/1/users</span><br><span class="line"></span><br><span class="line">// 根据名字获取公司</span><br><span class="line">http://localhost:3000/companies?name=华为</span><br><span class="line"></span><br><span class="line">// 根据多个名字获取公司</span><br><span class="line">http://localhost:3000/companies?name=华为&amp;name=阿里</span><br><span class="line"></span><br><span class="line">// 获取一页中只有两个数据</span><br><span class="line">&lt;!-- http://localhost:3000/companies?_page=1&amp;_limit=2 --&gt;</span><br><span class="line"></span><br><span class="line">// 根据名字升序排序  asc升序  desc降序</span><br><span class="line">&lt;!-- http://localhost:3000/companies?_sort=name&amp;_order=asc --&gt;</span><br><span class="line"></span><br><span class="line">// 获取年龄30及以上的</span><br><span class="line">http://localhost:3000/users?age_gte=30</span><br><span class="line"></span><br><span class="line">// 获取年龄30到40之间的</span><br><span class="line">http://localhost:3000/users?age_gte=30&amp;age_lte=40</span><br><span class="line"></span><br><span class="line">// 搜索用户信息</span><br><span class="line">http://localhost:3000/users?q=a</span><br><span class="line">http://localhost:3000/users?q=li</span><br></pre></td></tr></table></figure>

<h4 id="更改镜像源"><a href="#更改镜像源" class="headerlink" title="更改镜像源"></a>更改镜像源</h4><ul>
<li><p>改成淘宝镜像源 <code>npm config set registry https://registry.npm.taobao.org</code></p>
</li>
<li><p>检查 <code>npm config get registry</code> 或者 <code>npm info express</code></p>
</li>
<li><p>通过cnpm使用 <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
</li>
<li><p>使用 <code>cnpm install express</code></p>
</li>
</ul>
<h4 id="统一文件格式设置"><a href="#统一文件格式设置" class="headerlink" title="统一文件格式设置"></a>统一文件格式设置</h4><ul>
<li><p>新建 <code>.prettierrc</code>文件</p>
</li>
<li><p>里面写上</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span>, // 不使用分号</span><br><span class="line">    <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>  // 将双引号用单引号代替</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vue项目学习笔记"><a href="#vue项目学习笔记" class="headerlink" title="vue项目学习笔记"></a>vue项目学习笔记</h3><ul>
<li><p>编码测试</p>
<ul>
<li><p>npm run dev</p>
</li>
<li><p>编码,自动编译打包</p>
</li>
</ul>
</li>
<li><p>打包发布</p>
<ul>
<li><p>npm run build 编译打包生成dist文件夹</p>
</li>
<li><p>npm install -g serve</p>
</li>
<li><p>serve dist</p>
</li>
</ul>
</li>
<li><p>动态绑定类名, 一般用在满足请求路由才具有什么类名, 设置样式</p>
<ul>
<li><code>:class = &quot;&#123;active: &#39;/editData&#39; === $route.path&#125;&quot;</code></li>
</ul>
</li>
<li><p>git对项目进行版本控制</p>
<ul>
<li><ol>
<li>创建本地仓库</li>
</ol>
</li>
<li><ol start="2">
<li>创建远程仓库</li>
</ol>
</li>
<li><ol start="3">
<li>将本地和远程仓库关联</li>
</ol>
</li>
</ul>
</li>
<li><p>Vue.set(): 使新增的属性(默认没有)也有数据绑定,一般传入三个值 <code>Vue.set(foods, &#39;ciunt&#39;, 1)</code></p>
<ul>
<li><ol>
<li>对象</li>
</ol>
</li>
<li><ol start="2">
<li>属性名(字符串)</li>
</ol>
</li>
<li><ol start="3">
<li>属性值</li>
</ol>
</li>
</ul>
</li>
<li><p>移动端滑动库: better-scroll</p>
<ul>
<li><p>滑动问题</p>
<ul>
<li><ol>
<li>BScroll实例要为单例,防止多次创建出错</li>
</ol>
</li>
<li><ol start="2">
<li>单例在动态改变高度时有初次无法拉动问题,使用this.scroll.refresh() 重新统计高度</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>const rue = new RegExp(this.rule)</p>
<ul>
<li><p>可以使字符串rule变成真正的正则表达式</p>
</li>
<li><p>直接使用rue.text(this.content)</p>
</li>
</ul>
</li>
<li><p>将封装好的文件挂载到Vue.prototype里面,则在所有文件里面通过this就可以拿到</p>
<ul>
<li>挂载封装好的http.js文件 <code>Vue.prototype.$http(封装后的名字) = http(引入的http)</code></li>
</ul>
</li>
<li><p>async 和 await 作用是将异步请求的数据同步执行显示 ( 计时器里面的操作也是属于异步 ), 函数执行是先执行同步在执行异步, 使异步数据同步导出还可以用<strong>闭包</strong>或者<strong>promise</strong></p>
</li>
<li><p>只能输入数字<code>&lt;input type=&quot;text&quot; onkeyup=&quot;this.value=this.value.replace(/\D/g, &#39;&#39;)&quot;&gt;</code></p>
</li>
<li><p>注意事项：methods方法只要data数据其中之一发生变化，所有的方法都会执行一遍，性能不好，所以做好使用computed来改变data的数据值</p>
</li>
</ul>
<h3 id="vue3和vue2区别"><a href="#vue3和vue2区别" class="headerlink" title="vue3和vue2区别"></a>vue3和vue2区别</h3><ul>
<li>vue3的主要优势体现在：更快、更小、更易维护、更易于原生、开发更轻松</li>
</ul>
<h4 id="更快体现在"><a href="#更快体现在" class="headerlink" title="更快体现在"></a>更快体现在</h4><ul>
<li><p>virtual DOM 完全重写，mounting &amp; patching 提速 100%</p>
</li>
<li><p>更多编译时 （compile-time）提醒以减少 runtime 开销</p>
</li>
<li><p>基于 Proxy 观察者机制以满足全语言覆盖以及更好的性能</p>
</li>
<li><p>放弃 Object.defineProperty ，使用更快的原生 Proxy</p>
</li>
<li><p>组件实例初始化速度提高 100%</p>
</li>
<li><p>提速一倍/内存使用降低一半</p>
</li>
</ul>
<h4 id="更小体现在"><a href="#更小体现在" class="headerlink" title="更小体现在"></a>更小体现在</h4><ul>
<li><p>Tree-shaking 更友好</p>
</li>
<li><p>新的 core runtime：~ 10kb gzipped</p>
</li>
</ul>
<h4 id="命令和目录结构"><a href="#命令和目录结构" class="headerlink" title="命令和目录结构"></a>命令和目录结构</h4><ul>
<li><p>新加入了 TypeScript 以及 PWA 的支持</p>
</li>
<li><p>部分命令发生了变化：</p>
<ul>
<li><p>下载安装  npm install -g vue@cli</p>
</li>
<li><p>删除了vue list</p>
</li>
<li><p>创建项目   vue create</p>
</li>
<li><p>启动项目   npm run serve</p>
</li>
<li><p>默认项目目录结构也发生了变化：</p>
</li>
<li><p>移除了配置文件目录，config 和 build 文件夹</p>
</li>
<li><p>移除了 static 文件夹，新增 public 文件夹，并且 index.html 移动到 public 中</p>
</li>
<li><p>在 src 文件夹中新增了 views 文件夹，用于分类 视图组件 和 公共组件</p>
</li>
</ul>
</li>
</ul>
<h4 id="默认进行懒观察"><a href="#默认进行懒观察" class="headerlink" title="默认进行懒观察"></a>默认进行懒观察</h4><ul>
<li>在 2.x 版本里，不过数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效</li>
</ul>
<h4 id="更精准的变更通知"><a href="#更精准的变更通知" class="headerlink" title="更精准的变更通知"></a>更精准的变更通知</h4><ul>
<li>2.x 版本中，你使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行</li>
</ul>
<h4 id="data变更"><a href="#data变更" class="headerlink" title="data变更"></a>data变更</h4><ul>
<li>新版当中setup等效于之前2.0版本当中得到beforeCreate,和created，它是在组件初始化的时候执行，甚至是比created更早执行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 取而代之是使用以下的方式去初始化数据:</span><br><span class="line">// 使用name必须要用<span class="built_in">return</span>返回</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=<span class="string">&quot;hello&quot;</span>&gt;</span><br><span class="line">    123</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;obj.name&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import &#123;reactive&#125; from <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line"> <span class="function"><span class="title">setup</span></span>()&#123;</span><br><span class="line">   const obj = reactive(&#123;</span><br><span class="line">     name:<span class="string">&#x27;hello 番茄&#x27;</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="built_in">return</span> &#123;obj&#125;</span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Method变更"><a href="#Method变更" class="headerlink" title="Method变更"></a>Method变更</h4><ul>
<li><p>引用了vue提供的<strong>ref新函数</strong>，它的作用是用来创建一个引用值，它主要是对String,Number,Boolean的<strong>数据响应作引用</strong>。</p>
</li>
<li><p>也许有人会问，为什么不直接给count赋值，而是采用ref(0)这样的方式来创建呢，如果直接给count赋值就是等于把这个值直接抛出去了，就很难在找到它，而采用ref这种方法等于你在向外抛出去值的是同时，你还在它身上牵了一根绳子，方便去追踪它。</p>
</li>
<li><p>需要注意的时，在ref的函数中，如果你要去改变或者去引用它的值，ref的这个方法提供了一个value的返回值，对值进行操作。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;hello&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;button @click=<span class="string">&quot;increamt&quot;</span>&gt;button&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">import &#123;reactive,ref&#125; from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line"> <span class="function"><span class="title">setup</span></span>()&#123;</span><br><span class="line">   const count=ref(0)</span><br><span class="line">   const increamt=()=&gt;&#123;</span><br><span class="line">     count.value++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">return</span> &#123;count,increamt&#125;</span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期改变"><a href="#生命周期改变" class="headerlink" title="生命周期改变"></a>生命周期改变</h4><ul>
<li>如果要想在页面中使用生命周期函数的，根据以往2.0的操作是直接在页面中写入生命周期，而现在是需要去引用的，这就是为什么<strong>3.0能够将代码压缩到更低的原因</strong>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">created -&gt; 请使用 setup()</span><br><span class="line">beforeMount -&gt; onBeforeMount</span><br><span class="line">mounted -&gt; onMounted</span><br><span class="line">beforeUpdate -&gt; onBeforeUpdate</span><br><span class="line">updated -&gt; onUpdated</span><br><span class="line">beforeDestroy -&gt; onBeforeUnmount</span><br><span class="line">destroyed -&gt; onUnmounted</span><br><span class="line">errorCaptured -&gt; onErrorCaptured</span><br><span class="line"></span><br><span class="line">import &#123;reactive, ref, onMounted&#125; from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line"> <span class="function"><span class="title">setup</span></span>()&#123;</span><br><span class="line">   onMounted(()=&gt;&#123;</span><br><span class="line">     console.log(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="built_in">return</span> &#123;name,count,increamt&#125;</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>

<h4 id="computed变更"><a href="#computed变更" class="headerlink" title="computed变更"></a>computed变更</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用computed记得需要引入，这也是刚接触3.0容易忘记的事情</span><br><span class="line">const computeCount=computed(()=&gt;count.value*10)</span><br><span class="line"><span class="built_in">return</span> &#123;name,count,increamt,computeCount&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据的双向绑定"><a href="#数据的双向绑定" class="headerlink" title="数据的双向绑定"></a>数据的双向绑定</h4><ul>
<li><p>Vue2.0使用Object.defineProperty，双向绑定不能检测到下标的变化</p>
<ul>
<li>原理：通过使用 Object.defineProperty 来劫持对象属性的 geter 和 seter 操作，当数据发生改变发出通知</li>
</ul>
</li>
<li><p>Vue 3.0使用ES6的新特性porxy，proxy可以劫持整个对象，并返回一个新对象</p>
<ul>
<li>原理：通过ES6的新特性proxy来劫持数据，当数据改变时发出通知</li>
</ul>
</li>
</ul>
<h4 id="对文件的引用上"><a href="#对文件的引用上" class="headerlink" title="对文件的引用上"></a>对文件的引用上</h4><ul>
<li><p>Vue2.x中new出的实例对象，所有的东西都在这个vue对象上，这样其实无论你用到还是没用到，都会跑一遍。</p>
</li>
<li><p>vue3.0中可以用ES module imports按需引入，如：keep-alive内置组件、v-model指令，等等。</p>
</li>
</ul>
<h3 id="Vuex-js的使用"><a href="#Vuex-js的使用" class="headerlink" title="Vuex.js的使用"></a>Vuex.js的使用</h3><ul>
<li><p>概念: vuex是实现组建全局状态(数据)管理的一种机制,可以方便的实现组件之间数据的共享,数据是响应式的</p>
</li>
<li><p>中间组件 store</p>
</li>
<li><p>组件传值</p>
<ul>
<li><p>子组件获取父组件值 使用 getter</p>
<ul>
<li>父向子传值: v-bind属性绑定</li>
</ul>
</li>
<li><p>父组件获取子组件值 使用 mutation</p>
<ul>
<li>子向父传值: v-on事件绑定</li>
</ul>
</li>
<li><p>兄弟组件共享数据: EventBus</p>
<ul>
<li><p>$on  接收数据的那个组件</p>
</li>
<li><p>$emit  发送数据的那个组件</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="State属性-存储数据"><a href="#State属性-存储数据" class="headerlink" title="State属性(存储数据)"></a>State属性(存储数据)</h4><ul>
<li>State提供唯一的公共数据源,所有共享的数据都要统一放到Store的state中存储</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state: &#123; count: 0 &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>组件访问State中数据的第一种方式 <code>this.$store.state.全局数据名称</code> (template中可以省略this)</p>
</li>
<li><p>组件访问State中数据的第二种方式</p>
<ul>
<li><ol>
<li>从vuex中按需导入mapState 函数 <code>import &#123;mapState&#125; from &#39;vuex&#39;</code></li>
</ol>
</li>
<li><ol start="2">
<li>通过刚才导入的mapState函数, 将当前组件需要的全局数据, 映射为当前组件的computed计算属性</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([ <span class="string">&#x27;count&#x27;</span> ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mutation属性-改变数据"><a href="#Mutation属性-改变数据" class="headerlink" title="Mutation属性(改变数据)"></a>Mutation属性(改变数据)</h4><ul>
<li><p>Mutation用于变更Store中的数据</p>
<ul>
<li><p>只能通过mutation变更store数据,不可以直接操作store中的数据, (很难发现具体哪个地方对store数据进行更改了)</p>
</li>
<li><p>这种方式虽然繁琐,但是可以集中监控所有数据的变化, 有利于后期维护</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 定义Mutation</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        add(state, step)&#123; //第一个参数永远为state, 第二个参数为传参</span><br><span class="line">            state.count += step  // 变更数据状态</span><br><span class="line">        &#125;,</span><br><span class="line">        addN(state, step)&#123;  //第一个参数永远为state, 第二个参数为传参</span><br><span class="line">            state.count += step  // 变更数据状态</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 触发Mutation的第一种方法</span><br><span class="line">methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">handlel</span></span>()&#123;</span><br><span class="line">        this.<span class="variable">$store</span>.commit(<span class="string">&#x27;add&#x27;</span>, 3)  //通过commit函数调用Mutation中的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 触发mutation的第二种方式</span><br><span class="line">1. 从vuex中按需导入mapMutations函数 import &#123;mapMutations&#125; from <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">2. 通过刚才导入的mapMutations函数, 将需要的mutations函数, 映射为当前组件的methods方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">        ...mapMutations([<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;addN&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">3. 在本组件事件方法中直接调用this.add()方法或者直接在@click=<span class="string">&quot;addNAsync&quot;</span>使用方法</span><br></pre></td></tr></table></figure>

<h4 id="Action属性"><a href="#Action属性" class="headerlink" title="Action属性"></a>Action属性</h4><ul>
<li>触发actions异步任务时携带参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 定义Action</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    // ...省略代码</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        addN(state, step)&#123;</span><br><span class="line">            state.count += step</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        addNAsync(context, step)&#123;</span><br><span class="line">            setTimeout( () =&gt; &#123;</span><br><span class="line">                context.commit(<span class="string">&#x27;addN&#x27;</span>, step)</span><br><span class="line">            &#125;, 1000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 触发Action的第一种方式</span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handle</span></span> () &#123;</span><br><span class="line">        // 在调用dispatch函数</span><br><span class="line">        // 触发actions时携带参数</span><br><span class="line">        this.<span class="variable">$store</span>.dispatch(<span class="string">&#x27;addNAsync&#x27;</span>, 5)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 触发Action的第二种方法</span><br><span class="line">1. 从vuex中按需导入mapActions函数 import &#123;mapActions&#125; from <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">2. 将需要的actions函数, 映射为当前组件的methods方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">        ...mapActions([<span class="string">&#x27;addNAsync&#x27;</span>, <span class="string">&#x27;...&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">3. 直接在@click=<span class="string">&quot;addNAsync&quot;</span>使用方法</span><br></pre></td></tr></table></figure>

<h4 id="Getter属性-获取数据"><a href="#Getter属性-获取数据" class="headerlink" title="Getter属性(获取数据)"></a>Getter属性(获取数据)</h4><ul>
<li><p>用于对Store中的数据进行加工处理形成新的数据,类似Vue的计算属性</p>
</li>
<li><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：</p>
</li>
<li><p>Store中数据发生变化, Getter的数据也会跟着变化</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义Getter</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        showNum: state =&gt; &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="string">&#x27;当前最新的数量是[&#x27;</span> + state.count + <span class="string">&#x27;] &#x27;</span>  //返回的新值(字符串)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用Getters的第一种方式</span><br><span class="line">this.<span class="variable">$store</span>.getters.名称</span><br><span class="line"></span><br><span class="line">// 使用Getters的第二种方式</span><br><span class="line">import &#123; mapGetters &#125; from <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">&#x27;showNum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  // 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">      // ...</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你想将一个 getter 属性另取一个名字，使用对象形式：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters(&#123;</span><br><span class="line">  // 把 `this.doneCount` 映射为 `this.<span class="variable">$store</span>.getters.doneTodosCount`</span><br><span class="line">  doneCount: <span class="string">&#x27;doneTodosCount&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fish1010.github.io/2020/12/15/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckipkzn0z0000q4tra8t3faci" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Angular笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/20/Angular%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-11-20T02:48:45.000Z" itemprop="datePublished">2020-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/20/Angular%E7%AC%94%E8%AE%B0/">Angular笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><ul>
<li>安装Angular CLI</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @angular/cli</span><br></pre></td></tr></table></figure>

<ul>
<li>打包发布</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dist</span><br></pre></td></tr></table></figure>

<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>angular js的主体是页面中动态的数据，jq的主体是DOM</p>
</li>
<li><p>依赖对象：完成某个特定功能需要某个对象才能实现，这个对象就是依赖对象</p>
</li>
<li><p>依赖注入：依赖的对象以形参的形式被注入进来使用，这种方式就是声明式依赖注入</p>
</li>
<li><p>Angular的<code>$scope</code>对象就是依赖对象，并且是依赖注入的形式进行使用，所以形参必须是特定的名称</p>
</li>
</ul>
<h4 id="ng指令"><a href="#ng指令" class="headerlink" title="ng指令"></a>ng指令</h4><ul>
<li><p><code>ng-app</code>：告诉<code>angular</code>核心它管理当前标签所包含的整个区域，并且会自动创建<code>$rootScope</code>根作用域对象（是个对象）</p>
</li>
<li><p><code>ng-model</code>：将当前输入框的值与谁关联（属性名：属性值），并作为当前作用域对象<code>$rootScope</code>的属性。（双向数据绑定，初始（页面写的是<br><code>ng-model</code>，实际数据在model（内存中））显示的数据是从Model（模型（内存）） =&gt; View（视图（页面）），改变数据之后是从View =&gt; Model）</p>
</li>
<li><p><code>ng-init</code>：用来初始化（在页面写<code>ng-init=&quot;aaa&quot;</code>）当前作用域变量（单向数据绑定View =&gt; Model）</p>
</li>
<li><p><code>表达式(&#123;&#123;&#125;&#125;)</code>：显示数据，从当前作用域对象的指定属性名上取（单向数据绑定Model =&gt; View）</p>
</li>
<li><p><code>ng-controller</code>：指定控制器构造函数，Angular会自动new此函数创建控制器对象，同时Angular还有创建一个新的作用域对象<code>$scope</code>，它是<code>$rootScope</code>的子对象，在控制器函数中声明<code>$scope</code>形参，形参必须是<code>$scope</code>，Angular会自动将<code>$scope</code>传入</p>
</li>
<li><p><code>ng-click</code>：点击监听，值为函数调用，可以传入$event</p>
</li>
<li><p><code>ng-bind</code>：解决使用双大括号表达式显示数据闪屏，闪屏原因是因为代码从上往下解析，angular.js是在最下面引入的，最初解析到大括号处，以普通文本显示出来，还不能知道这是angular.js的语法，<code>ng-bind</code>能解决问题的原因是，<code>ng-bind</code>属于标签属性，解析不认识也不会显示，只会认识标签里面的内容，所以就会默认标签中间为空。</p>
</li>
<li><p><code>ng-repeat</code>：遍历数组显示数据，数组有几个元素就会产生几个新的作用域</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$index(索引)  $first(判断是否是第一个)</span><br><span class="line">$last(判断是否是最后一个) $middle(除了第一个和最后一个的中间值)</span><br><span class="line">$old(判断是否是奇数)  $even(判断是否是偶数)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ng-show</code>：布尔类型，结果为true显示</p>
</li>
<li><p><code>ng-hide</code>：布尔类型，结果为true隐藏</p>
</li>
<li><p><code>ng-class</code>：动态引用定义的样式{aclass：true， bclass：false}</p>
</li>
<li><p><code>ng-style</code>：动态引用通过js指定的样式对象{color: ‘red’, background: ‘blue’}</p>
</li>
<li><p><code>ng-mouseenter</code>：鼠标移入监听，值为函数调用，可以传$event</p>
</li>
<li><p><code>ng-mouseleave</code>：鼠标移出监听，值为函数调用，可以传$event</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fish1010.github.io/2020/11/20/Angular%E7%AC%94%E8%AE%B0/" data-id="ckhpod7i20000ectrf18l8jac" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TypeScript学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/20/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-11-20T01:34:48.000Z" itemprop="datePublished">2020-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/20/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">TypeScript笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="基础变量"><a href="#基础变量" class="headerlink" title="基础变量"></a>基础变量</h4><h5 id="布尔值boolean"><a href="#布尔值boolean" class="headerlink" title="布尔值boolean"></a>布尔值boolean</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>/<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h5 id="数字number"><a href="#数字number" class="headerlink" title="数字number"></a>数字number</h5><ul>
<li>typescript里的数都是浮点型，类型都是number，支持二进制八进制十进制十六进制</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">7</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">9</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fish1010.github.io/2020/11/20/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckhplr9pi00000ctrcat806hq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-平安实习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/17/%E5%B9%B3%E5%AE%89%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-11-17T01:30:59.000Z" itemprop="datePublished">2020-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/17/%E5%B9%B3%E5%AE%89%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/">平安实习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="vscode代码快捷输入"><a href="#vscode代码快捷输入" class="headerlink" title="vscode代码快捷输入"></a>vscode代码快捷输入</h4><ul>
<li>设置 - 用户代码片段 - 搜索对应语言 - 配置</li>
</ul>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><ul>
<li><p>概念：数据可以从View（视图层）流向Model（模型），也可以反过来</p>
</li>
<li><p>视图（View（页面））：也就是我们的页面（Angular中主要是指令和表达式）</p>
</li>
<li><p>模型（Model（内存））：作用域对象（当前为<code>$rootScope</code>），它可以包含一些属性或方法</p>
</li>
<li><p><code>ng-model</code>是双向数据绑定，而<code>&#123;&#123;&#125;&#125;`是单向数据绑定

- 改变View中的数据，Model对象的对应属性也会随之改变：`ng-mmodel`；数据从View => Model

- 当Model域对象的属性发生改变，页面对应的数据随之改变：`&#123;&#123;&#125;&#125;</code>表达式；数据从Model =&gt; View</p>
</li>
</ul>
<h4 id="命令式和声明式区别"><a href="#命令式和声明式区别" class="headerlink" title="命令式和声明式区别"></a>命令式和声明式区别</h4><ul>
<li><p>命令式更注重的是执行过程</p>
</li>
<li><p>声明式注重执行的结果，对命令的局部封装</p>
</li>
</ul>
<h4 id="git-push遇到dist文件冲突解决办法"><a href="#git-push遇到dist文件冲突解决办法" class="headerlink" title="git push遇到dist文件冲突解决办法"></a>git push遇到dist文件冲突解决办法</h4><ul>
<li>重新build -&gt; <code>git add .</code> -&gt; <code>git commit</code>（后面什么都不写，冲突合并）</li>
</ul>
<h4 id="怎么连接本地服务"><a href="#怎么连接本地服务" class="headerlink" title="怎么连接本地服务"></a>怎么连接本地服务</h4><ul>
<li><p>vue在vue.config.js里面配置</p>
</li>
<li><p>angular在webpack.dev.js里面配置</p>
</li>
</ul>
<h4 id="angular发布流程"><a href="#angular发布流程" class="headerlink" title="angular发布流程"></a>angular发布流程</h4><ul>
<li><p>本地打包 <code>npm run dist</code></p>
</li>
<li><p>提交到远端仓库</p>
</li>
</ul>
<h4 id="angular2富文本编辑器ng2-ckeditor的使用"><a href="#angular2富文本编辑器ng2-ckeditor的使用" class="headerlink" title="angular2富文本编辑器ng2-ckeditor的使用"></a>angular2富文本编辑器ng2-ckeditor的使用</h4><ul>
<li>下载ckeditor</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址：https://ckeditor.com/ckeditor-4/download/</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将下载的压缩文件解压到项目相关目录</p>
</li>
<li><p>在index.html中引入</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./assets/ckeditor/ckeditor.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在html文件中使用编辑器的组件</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ckeditor</span></span></span><br><span class="line"><span class="tag">  [(<span class="attr">ngModel</span>)]=<span class="string">&quot;content&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">debounce</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">  [<span class="attr">config</span>]=<span class="string">&quot;config&quot;</span>  </span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ckeditor</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在ts文件中</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">content=<span class="string">&#x27;&#x27;</span></span><br><span class="line">config: <span class="built_in">any</span> = &#123;</span><br><span class="line">  <span class="comment">// 文件上传路径</span></span><br><span class="line">  filebrowserUploadUrl: <span class="string">&#x27;/api-admin/public/flashUpload&#x27;</span>,</span><br><span class="line">  <span class="comment">// 图片上传后端url</span></span><br><span class="line">  filebrowserImageUploadUrl: <span class="string">&#x27;/api/cas/patent/weixin/admin/upload/ckEditorWindowUpload?id=1&#x27;</span>,</span><br><span class="line">  <span class="comment">// 打开窗口上传</span></span><br><span class="line">  uploadUrl: <span class="string">&#x27;/api/cas/patent/weixin/admin/upload/ckEditorWindowUpload?id=1&#x27;</span>,</span><br><span class="line">  <span class="comment">// 拖拽上传</span></span><br><span class="line">  mage_previewText: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="comment">// html5Video上传url</span></span><br><span class="line">  filebrowserHtml5videoUploadUrl: <span class="string">&#x27;/api/cas/patent/weixin/admin/upload/ckEditorWindowUpload?id=1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>安装组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ng2-ckeditor --save</span><br></pre></td></tr></table></figure>

<ul>
<li>引入需要的模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ckEditorModule &#125; <span class="keyword">from</span> <span class="string">&#x27;ng2-ckeditor&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>箭头函数只有一个参数，不加括号</p>
</li>
<li><p>括号后面要加分号，大括号后面不用加</p>
</li>
</ul>
<h4 id="解决disable多次点击卡死情况"><a href="#解决disable多次点击卡死情况" class="headerlink" title="解决disable多次点击卡死情况"></a>解决disable多次点击卡死情况</h4><ul>
<li>使用loading代替disable，使用try{}finally{}</li>
</ul>
<h4 id="try-catch和try-finally的区别"><a href="#try-catch和try-finally的区别" class="headerlink" title="try-catch和try-finally的区别"></a>try-catch和try-finally的区别</h4><ul>
<li>catch只有在try中报错才会进入执行，finally是无论try中执行是否成功，都会进入执行。</li>
</ul>
<h4 id="position的值（css3新提出的）"><a href="#position的值（css3新提出的）" class="headerlink" title="position的值（css3新提出的）"></a>position的值（css3新提出的）</h4><ul>
<li><p>sticky：粘性定位，属于relative和fixed两者结合，须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>
</li>
<li><p>static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p>
</li>
<li><p>inherit：规定应该从父元素继承 position 属性的值。</p>
</li>
<li><p>initial：</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fish1010.github.io/2020/11/17/%E5%B9%B3%E5%AE%89%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckhlazxvz000008tr15qp00yd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-亚信实习记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/16/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2020-09-16T02:34:03.000Z" itemprop="datePublished">2020-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/16/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/">亚信实习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>启动问题:    把 <code>npm run dev</code>改成<code>npm start</code></p>
</li>
<li><p>安装依赖<code>npm install</code>:     把文件夹内的yarn.lock和package-lock.json删掉再安装</p>
</li>
<li><p>async与await是什么?</p>
<ul>
<li><p>async表示这是一个async函数, await只能用在async函数里面,不能单独使用</p>
</li>
<li><p><strong>async返回的是一个promise对象</strong>, await就是等待这个promise的返回结果后,在继续执行</p>
</li>
<li><p><strong>await等待的是一个promise对象, 后面必须跟一个promise对象</strong>, 但不必写then(), 直接就可以得到返回值</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然async函数依然是异步的，但是里面await的Promise是同步的，这样就有可能造成代码阻塞。如果不是有需要完成不必这样做。</p>
</blockquote>
<ul>
<li><p><strong>localStorage</strong>和<strong>sessionStorage</strong>一样都是用来存储客户端临时信息的对象。<strong>localStorage</strong>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。而<strong>sessionStorage</strong>存储的数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<strong>sessionStorage</strong>不是一种持久化的本地存储</p>
</li>
<li><p>一个字符串使用trim方法   ：省略掉中间字符串 前后的空格， 截取中间的字符串</p>
</li>
<li><p>this.$nextTick( () =&gt; {} ) 表示状态数据跟新完成, 界面异步显示之前调用的函数</p>
</li>
<li><p>as</p>
</li>
<li><p>qs</p>
</li>
<li><p>axios</p>
</li>
<li><p>路由还可以配置meta 来控制是否显示当前路由</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meta: &#123;</span><br><span class="line">    showData: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">路由组件中&lt;DataComponent v-show=<span class="string">&quot;$route.meta.showData&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@click = “$router.back()” 用于路由页面返回  </p>
</li>
<li><p>$route: 是当前路由对象,一些当前路由信息的数据容器, path/meta/query/params</p>
</li>
<li><p>$router: 路由器对象, 包含一些操作路由的功能函数, 来实现编程式导航, 路由跳转</p>
</li>
<li><p>router-view / router-link / keep-alive</p>
</li>
<li><p>keep-alive用来缓存组件,避免多次加载相应的组件,减少性能消耗，简单一点来说就是从页面1链接到其他页面后回退到页面1不用在重新执行页面1的代码，只会从缓存中加载之前已经缓存的页面1，这样可以减少加载时间及性能消耗，提高用户体验性。</p>
</li>
<li><p>swiper: 设置轮播图库 npm install –save swiper ( 具体查看swiper官网 )</p>
<ul>
<li>引入 <code>import Swiper from &#39;swiper&#39;</code> <code>import &#39;swiper/dist/css/swiper.min.css&#39;</code></li>
</ul>
</li>
<li><p>watch: {} 监听属性</p>
</li>
<li><p>解决data类型不匹配问题  期望是数组,给了个字符串, 转换类型</p>
</li>
<li><p>解决length未定义问题, 加个v-if,  有长度才渲染</p>
</li>
<li><p>解决slice未定义问题, 在数组加一个空数组 [ ] 的情况 <code>(array || [] ).slice(0, 1)</code></p>
</li>
<li><p>gitlab</p>
</li>
<li><p>v-contextmenu</p>
</li>
<li><p>父子组件函数方法传值调用</p>
</li>
<li><p>get set方法</p>
</li>
<li><p>mapstate展开</p>
</li>
<li><p>ElementUI:  <code>&lt;https://element.eleme.cn/#/zh-CN/component/installation&gt;</code></p>
</li>
<li><p>scss</p>
</li>
<li><p>height:  高度充满项目的写法<code>style=&quot;height: calc(100vh - 100px);&quot;</code></p>
</li>
<li><p>lodash: 提供了一些数组,对象常用的方法, 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单</p>
<ul>
<li>cloneDeep</li>
</ul>
</li>
<li><p>svg:  </p>
</li>
<li><p>quill(文本编辑器):  </p>
<ul>
<li><p><strong>安装依赖</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-quill-editor --save</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用</strong></p>
<p>（1）在“项目名\src\main.js”引入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueQuillEditor <span class="keyword">from</span> <span class="string">&#x27;vue-quill-editor&#x27;</span></span><br></pre></td></tr></table></figure>

<p>（2）在具体vue文件中引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-row&gt;  </span><br><span class="line">    &lt;quill-editor v-model=<span class="string">&quot;content&quot;</span> :options=<span class="string">&quot;editorOption&quot;</span></span><br><span class="line">      @blur=<span class="string">&quot;onEditorBlur($event)&quot;</span></span><br><span class="line">      @focus=<span class="string">&quot;onEditorFocus($event)&quot;</span></span><br><span class="line">      @change=<span class="string">&quot;onEditorChange($event)&quot;</span>&gt;  </span><br><span class="line">    &lt;/quill-editor&gt;</span><br><span class="line">  &lt;/el-row&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对象不能产生作用域( 箭头函数的经典面试题, 对象里面的箭头函数的this指向window全局 )</p>
</li>
<li><p>ref=”abc”:  绑定组件的内容, 通过<code>this.$refs.abc.textContent</code>获取内部文本内容</p>
</li>
<li><p>@click.stop:  阻止单击事件继续传播</p>
</li>
<li><p>ECharts引入图表: 颜色标题模块的个性化设置</p>
</li>
<li><p>解决导航菜单路由点击不改变样式问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">导航绑定默认</span><br><span class="line">:<span class="keyword">default</span>-active=<span class="string">&quot;$route.path&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么解决路由多次点击出错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在main.js中加入</span><br><span class="line"><span class="keyword">const</span> originalPush = Router.prototype.push</span><br><span class="line">Router.prototype.push = <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> originalPush.call(<span class="built_in">this</span>, location).catch(<span class="function"><span class="params">err</span> =&gt;</span> err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Form 表单验证rules的使用:  </p>
</li>
<li><p>slot-scope = “scope “ :  绑定这一行数据, 渲染方式有 和 </p>
</li>
<li><p>Object.assign():  方法的第一个参数是目标对象，后面的参数都是源对象。</p>
</li>
</ul>
<blockquote>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br><span class="line"></span><br><span class="line">如果只有一个参数，<span class="built_in">Object</span>.assign会直接返回该参数。</span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj) === obj <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">如果该参数不是对象，则会先转成对象，然后返回。</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line">由于<span class="literal">undefined</span>和<span class="literal">null</span>无法转成对象，所以如果它们作为参数，就会报错。</span><br><span class="line"></span><br><span class="line">如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<span class="literal">undefined</span>和<span class="literal">null</span>不在首参数，就不会报错。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>:active=””:  实现点击切换</p>
</li>
<li><p>JSON.stringify(value[, replacer [, space]]):  把对象的类型转换成字符串类型</p>
<ul>
<li>value:  将要序列化成 一个JSON 字符串的值。</li>
<li>replacer 可选<br>可以为数组或函数<br>如果为数组：则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中，replacer作key值<br>如果为函数：则把系列化后的每一个对象（记住是每一个）传进方法里面进行处理</li>
<li>space 可选<br>指定缩进用的空白字符串<br>如果省略的话，那么显示出来的值就没有分隔符。直接输出来<br>如果是一个数字的话，那么它就定义缩进几个字符，范围是：0到10（数字小于1，则默认为0，大于10，则默认为10）<br>如果是一些转义字符，比如“\t”，表示回车，那么它每行一个回车。<br>如果仅仅是字符串，就在每行输出值的时候把这些字符串附加上去就OK。当然，最大长度也是10个字符</li>
</ul>
</li>
<li><p>@click.native:  </p>
<ul>
<li>当父组件中引入子组件的时候，当要触发子组件点击事件的时候@click 不生效。<br> 有两种解决方式<br> 1.@click.native<br> 2.在子组件中添加this.$emit ( “事件名” ，value )方法 将子组件的值传到父组件。</li>
</ul>
</li>
<li><p>exec(): 用于检索字符串中的正则表达式的匹配。如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。</p>
</li>
</ul>
<blockquote>
<p>如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。论 RegExpObject 是否是全局模式，exec() 都会把完整的细节添加到它返回的数组中。这就是 exec() 与 String.match() 的不同之处，后者在全局模式下返回的信息要少得多。</p>
</blockquote>
<ul>
<li><p>slot:  主要是传标签( props主要是传值 ) , 源标签用name标识, 目的标签用slot等于name值来传入</p>
<ul>
<li>slot插槽，它让组件的实现变的更加灵活。插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件</span><br><span class="line">    &lt;slotOne1&gt;</span><br><span class="line">      &lt;p style=<span class="string">&quot;color:red&quot;</span>&gt;我是父组件插槽内容&lt;/p&gt;</span><br><span class="line">    &lt;/slotOne1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">在子组件中写入slot，slot所在的位置就是父组件要显示的内容</span><br><span class="line"></span><br><span class="line">子组件(slotOne1)</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;slotOne1&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;我是slotOne1组件&lt;/div&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">  我是父组件</span><br><span class="line">  我是slotOne1组件</span><br><span class="line">  我是父组件插槽内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>flex布局</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">父级身上的属性</span><br><span class="line">flex-direction: row(水平排列) | column(垂直排列) | row/column-reverse</span><br><span class="line">align-items: 垂直排列方式</span><br><span class="line">  center 居中</span><br><span class="line">  flex-end 底部</span><br><span class="line">  flex-start 开始</span><br><span class="line">justify-content: 子元素水平排列方式</span><br><span class="line">  center 居中</span><br><span class="line">  flex-start 居左</span><br><span class="line">  flex-end 居右</span><br><span class="line">  space-between 两端对齐</span><br><span class="line">  space-around 拉手分布</span><br><span class="line">align-content: 多行的时候,垂直排列</span><br><span class="line">flex-wrap: wrap(根据宽度换行) | nowrap(默认不换行) | wrap-reverse</span><br><span class="line">flex-flow: row wrap</span><br><span class="line">  flex-direction和flex-wrap的结合体</span><br><span class="line"></span><br><span class="line">子元素身上属性</span><br><span class="line">flex: <span class="number">1</span> (指的是一个系数)</span><br><span class="line">order: 设置数值, 数值越小越靠前</span><br><span class="line">flex-grow: 设置放大比例,默认为<span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决vue中el-tab-pane切换其他tab页不显示问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-tabs v-model=<span class="string">&quot;activeName&quot;</span> @tab-click=<span class="string">&quot;handleClick&quot;</span>&gt; <span class="comment">//给tabs添加v-model</span></span><br><span class="line">  &lt;el-tab-pane label=<span class="string">&quot;tab1&quot;</span> name=<span class="string">&quot;first&quot;</span> :key=<span class="string">&quot;&#x27;first&#x27;&quot;</span>&gt;</span><br><span class="line">    &lt;child1 v-<span class="keyword">if</span>=<span class="string">&quot;isChildUpdate1&quot;</span>&gt;&lt;/child1&gt;</span><br><span class="line">  &lt;/el-tab-pane&gt;</span><br><span class="line">  &lt;el-tab-pane label=<span class="string">&quot;tab2&quot;</span> name=<span class="string">&quot;second&quot;</span> :key=<span class="string">&quot;&#x27;second&#x27;&quot;</span>&gt;</span><br><span class="line">    &lt;child2 v-<span class="keyword">if</span>=<span class="string">&quot;isChildUpdate2&quot;</span>&gt;&lt;/child2&gt;</span><br><span class="line">  &lt;/el-tab-pane&gt;</span><br><span class="line">&lt;/el-tabs&gt;</span><br><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        isChildUpdate1: <span class="literal">true</span>,</span><br><span class="line">        isChildUpdate2: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">handleClick (vm) &#123;</span><br><span class="line">      <span class="keyword">if</span>(vm.name == <span class="string">&quot;first&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.isChildUpdate1 = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.isChildUpdate2 = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(vm.name == <span class="string">&quot;second&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.isChildUpdate1 = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.isChildUpdate2 = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改select, input, collapse, 的原生icon图标样式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.el-icon-arrow-right::before&#123;</span><br><span class="line">    content: <span class="string">&#x27;\e60e&#x27;</span>;</span><br><span class="line">    color: #666666;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ClipboardJS复制剪切</p>
</li>
<li><p><code>@keyup.enter.native.stop=&quot;() =&gt; &#123;&#125;&quot;</code>   <code>@keyup.space.native.stop=&quot;() =&gt; &#123;&#125;&quot;</code></p>
<ul>
<li>如果用了封装组件的话，比如element，这个时候使用按键修饰符需要加上.native</li>
<li>例如: <code>&lt;el-input v-model=&quot;account&quot; placeholder=&quot;请输入账号&quot; @keyup.enter.native=&quot;search&quot;&gt;&lt;/el-input&gt;</code></li>
</ul>
</li>
<li><p>通常我们使用iframe直接直接在页面嵌套iframe标签指定src就可以了。</p>
<ul>
<li><code>&lt;iframe src=&quot;www.baidu.com&quot;&gt;&lt;/iframe&gt;</code></li>
</ul>
</li>
<li><p>只要 协议 、 域名 、 端口 有任何一个 不同, 都被当作是 不同 的域</p>
<ul>
<li>CORS（Corss-Origin Resource Sharing,跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。</li>
<li>将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。<br>注意：不能将值设置为URL中不包含的域；松散的域名不能再设置为紧绷的域名。</li>
<li>图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。缺点：只能发送GET请求；无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。</li>
<li>JSONP由两部分组成：回调函数和数据 回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。数据是传入回调函数中的JSON数据。优点：能够直接访问响应文本，可用于浏览器与服务器间的双向通信。缺点：JSONP从其他域中加载代码执行，其他域可能不安全；难以确定JSONP请求是否失败。</li>
<li>Comet可实现服务器向浏览器推送数据。Comet是实现方式：长轮询和流短轮询即浏览器定时向服务器发送请求，看有没有数据更新。长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。</li>
<li>WebSocket可在一个单独的持久连接上提供全双工、双向通信。WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。注意：必须给WebSocket构造函数传入绝对URL；WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。优点：在客户端和服务器之间发送非常少的数据，减少字节开销。</li>
</ul>
</li>
<li><p>以下是四种touch事件</p>
<ul>
<li>touchstart:     //手指放到屏幕上时触发</li>
<li>touchmove:      //手指在屏幕上滑动式触发</li>
<li>touchend:    //手指离开屏幕时触发</li>
<li>touchcancel:     //系统取消touch事件的时候触发，这个好像比较少用</li>
</ul>
</li>
<li><p>方法的返回值</p>
<ul>
<li>Object.keys() 该方***返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。</li>
<li>String.prototype.split() split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。返回数组</li>
<li>Array.prototype.join() join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。返回字符串。</li>
<li>Promise.all() Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。返回的是promise对象。</li>
</ul>
</li>
<li><p>ascon await 将异步数据实现同步操作,相当于等异步的任务完成后, 在等await执行</p>
</li>
<li><p>style=”display:block; width: 147px; margin-mottom: 4px” 与 :style=”{lineHeight:’17px’, marginBottom: ‘2px’, fontSize: (item.con.fontSize+’px’)||’12px’}” 与 :class=”[(shareStyle.isShow || starStyle.isShow) ? ‘isShowBtn’ :’notShowBtn’]”</p>
</li>
<li><p>this.$set(this.specialActiveItem.option.contentSelect, this.dataIndex, this.currSelectItem)  同步更新设置contentSelect数组或者对象,页面同步渲染显示, 第二个参数是index或者key,第三个参数是value</p>
</li>
<li><p>难点:</p>
<ul>
<li>编辑区域的弹窗提示位置问题,缩放问题,分辨率问题</li>
<li>h5页面的视频流初始化问题,点赞分享播放推荐语消失</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fish1010.github.io/2020/09/16/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95/" data-id="ckf4tak5c0001zctrf0rbe0zl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-博客搭建笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-09-15T09:48:18.940Z" itemprop="datePublished">2020-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/">博客的搭建步骤</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="blog-init"><a href="#blog-init" class="headerlink" title="blog init"></a>blog init</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;file name&gt;</span><br><span class="line">cd &lt;file name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<h4 id="Run-localhost-server"><a href="#Run-localhost-server" class="headerlink" title="Run localhost server"></a>Run localhost server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h4 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fish1010.github.io/2020/09/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/" data-id="ckf4ta4dx0000zctr2l2fa4ym" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/15/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">React学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/12/15/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Vue学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/11/20/Angular%E7%AC%94%E8%AE%B0/">Angular笔记</a>
          </li>
        
          <li>
            <a href="/2020/11/20/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">TypeScript笔记</a>
          </li>
        
          <li>
            <a href="/2020/11/17/%E5%B9%B3%E5%AE%89%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/">平安实习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Yebo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>